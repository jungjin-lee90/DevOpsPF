[
  {
    "title": "AWS EC2와 Docker를 활용한 CI/CD",
    "date": "2025-05",
    "tags": ["Jenkins", "Docker", "Github", "EC2"],
    "summary": "GitHub → Jenkins → Docker 이미지 빌드 자동화 구성 실험.",
    "code_path": "https://raw.githubusercontent.com/jungjin-lee90/resume/main/Jenkinsfile",
    "image": "jenkins_ci_diagram.png",
    "result": "Jenkins 빌드 후 Docker 이미지가 정상적으로 푸시되었고, 트리거 기반 빌드 자동화 성공.",
    "resultimage": "jenkins_ci_ui.png",
    "reflection": "EC2에 Jenkins를 설치하고, 보안 그룹을 통해 특정 포트로의 접근만 허용하는 구조로 구성하였다.\nGitHub 저장소에서 Push 이벤트가 발생하면 WebHook을 통해 Jenkins EC2 인스턴스로 이벤트가 전달되며,\n해당 이벤트 정보를 기반으로 빌드 이름을 동적으로 정의하도록 구현하였다.\nDocker 이미지 빌드 단계에서는 현재 시간을 태그로 부여하여 이미지가 덮어씌워지지 않도록 처리하였고,\n30초 간격의 헬스체크를 추가하여 컨테이너 상태를 지속적으로 확인하였다.\n마지막으로 빌드가 완료되면 소스코드를 압축한 후 GitHub Release에 업로드하여 버전별 파일 관리가 가능하도록 구성하였다.\n\n파이프라인 구축을 하고 나서 아쉬웠던 부분은 세 가지 정도 있었다. 첫째로는 보안적인 부분이었다. 보안 그룹을 통한 접근 통제만 하고 있었기 때문에 특정 포트로의 접근이 자유롭게 가능했다는 점이 아쉬웠다. 이 점을 보완하려면 ALB와 HTTPS의 적용 또는 Nginx 같은 프록시 서버의 사용 등이 있을 것 같다.\n둘째로는 Jenkins 서버와 Docker 배포 인스턴스가 동일한 인스턴스였다는 점이다. 이런 구조에서는 자원 부족 현상이 발생할 수 있기 때문에, ECR을 사용하여 Docker 이미지를 분리했어야 했다고 생각한다.\n세번째로 branch의 분리였다. 기본적으로 프로젝트를 진행하면 개발과 릴리즈 버전을 따로 관리하는데, 이번 프로젝트에서는 시간이 부족했기에 하나의 branch에 작업을 진행하여 확장성이 많이 부족했다고 생각한다.\n이번 프로젝트는 아무래도 EC2를 활용하다 보니 비용이 발생하는 프로젝트였기에, 완전한 운영형 프로젝트라고 보기는 어려웠다. 다음 프로젝트에서는 이러한 보완점들을 개선하여 좀 더 실용적인 구조로 진행할 계획이다."
  },
  {
    "title": "Jenkins + SVN으로 CI/CD 구축",
    "date": "2024-04-21",
    "tags": ["Jenkins", "SVN", "CI/CD"],
    "summary": "SVN 기반 형상 관리 환경에서 Jenkins를 활용한 CI/CD 자동화를 구축하는 과정을 정리했다. Jenkins 설치 및 SVN 저장소 연동부터 시작해 Poll SCM과 WebHook 트리거 방식 비교, 커밋 메시지 기반 빌드 제목 설정, 빌드 오류 해결까지 실제 업무에서 겪을 수 있는 흐름을 그대로 반영하였다.",
    "code_path": "https://raw.githubusercontent.com/jungjin-lee90/resume/main/other/SVNProjectCode",
    "result": "SVN 저장소에서 커밋이 발생하면 Jenkins가 자동으로 변경을 감지하고 빌드를 수행하도록 구성되었으며, 최종적으로 WebHook을 활용하여 빠르고 효율적인 트리거 기반 자동화를 성공적으로 구현하였다.",
    "reflection": "초기에는 Poll SCM 주기로 인해 실시간성이 떨어졌고, WebHook 설정 시 인증 문제로 애를 먹었지만 post-commit 스크립트를 통해 안정적으로 해결하였다. 또한 SVN 버전 호환 문제나 커밋 메시지 파싱에서 실제로 겪는 이슈들을 해결하며 실전 감각을 익힐 수 있었다."
  },
  {
    "title": "Kubernetes 설치부터 ArgoCD 기반 자동 배포까지 실습",
    "date": "2024-03-19",
    "tags": ["Kubernetes", "ArgoCD", "GitOps", "CI/CD"],
    "summary": "KVM을 활용한 멀티 노드 클러스터 구성부터 시작해 Kubernetes 설치, 클러스터 설정, GitHub 연동 애플리케이션 컨테이너화 및 자동 배포까지 CI/CD 전체 흐름을 실습하였다. GitHub Actions를 활용한 Docker 이미지 빌드, 태깅, 푸시 그리고 ArgoCD를 통한 GitOps 방식 배포 구조를 구성하였고, 마지막으로 동시성 제어 및 에러 핸들링까지 다루었다.",
    "code_path": "code/github_jenkins_pipeline.groovy",
    "result": "GitHub에서 코드 변경 → Docker 이미지 빌드 → GitHub Container Registry 푸시 → ArgoCD가 이를 감지해 Kubernetes 클러스터에 자동 배포되는 흐름을 성공적으로 구현하였다. 실전에서도 활용 가능한 GitOps 기반 워크플로우로 확장 가능성을 확인하였다.",
    "reflection": "Kubernetes 클러스터 구성 중 Calico 설치와 노드 연결 과정에서 수차례 충돌이 발생했지만 원인을 파악하고 해결하는 과정에서 네트워크 플러그인 동작 방식과 클러스터 토폴로지에 대한 이해를 높일 수 있었다. ArgoCD 설정에서 YAML 구조와 동기화 정책 등 실전 환경에서 필요한 설정들을 손에 익힐 수 있었고, GitHub Actions에서 동시성 제어(concurrency)를 통한 충돌 방지도 좋은 경험이었다."
  },
  {
    "title": "GitHub + Jenkins 기반 Docker CI/CD 구축",
    "date": "2025-05-15",
    "tags": ["GitHub", "Jenkins", "Docker", "CI/CD"],
    "summary": "GitHub 저장소에서 소스코드를 Jenkins에서 감지하고, Docker 이미지를 빌드 후 배포하는 CI/CD 구조를 구성하였다. GitHub Webhook으로 Jenkins 파이프라인을 트리거하고, Dockerfile을 기반으로 이미지 빌드 및 로컬 서버에 배포하는 과정을 실습하였다.",
    "code_path": "code/github_jenkins_pipeline.groovy",
    "result": "Jenkins와 GitHub 연동을 통해 코드 푸시 → 자동 빌드 → Docker 컨테이너로 실행까지 일련의 자동화 흐름을 성공적으로 구현하였다. 추후 ECR, EKS 연동을 통해 확장 가능성을 확인하였다.",
    "reflection": "GitHub Webhook 인증 과정과 Jenkins에서 Docker 명령어 실행 권한 설정 부분에서 시행착오가 있었지만, 로컬 테스트 기반으로 빠르게 문제를 해결하며 Jenkins Declarative Pipeline 구조에 익숙해질 수 있었다."
  }
]

